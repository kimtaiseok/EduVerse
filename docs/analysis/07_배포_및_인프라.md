# 07. 배포 및 인프라

## 배포 전략 개요

EduVerse는 **컨테이너 기반 배포**와 **서버리스 아키텍처**를 결합한 하이브리드 배포 전략을 사용합니다.

### 배포 옵션
1. **로컬 개발** - Flask 개발 서버
2. **Docker 컨테이너** - 로컬/클라우드 모두 지원
3. **Google Cloud Run** - 프로덕션 서버리스 배포

---

## 1. 로컬 개발 환경

### 1.1 개발 서버 실행

#### 방법 1: Flask 개발 서버
```bash
# 의존성 설치
pip install -r requirements.txt

# Flask 앱 실행
python main.py

# 기본 포트: 5000
# 접속: http://localhost:5000
```

**Flask 기본 설정** ([main.py](../../main.py:580)):
```python
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
```

#### 방법 2: Gunicorn (프로덕션 모드)
```bash
gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app

# 접속: http://localhost:8080
```

### 1.2 환경 변수
**현재**: 환경 변수 없음 (Firebase Project ID 하드코딩)

**권장 개선**:
```bash
# .env 파일
FIREBASE_PROJECT_ID=my-python-65210-65c44
FLASK_ENV=development
PORT=5000
```

```python
# main.py
import os
from dotenv import load_dotenv

load_dotenv()

PROJECT_ID = os.getenv('FIREBASE_PROJECT_ID', 'my-python-65210-65c44')
PORT = int(os.getenv('PORT', 5000))

firebase_admin.initialize_app(options={'projectId': PROJECT_ID})

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=PORT)
```

### 1.3 핫 리로드
Flask 개발 서버는 기본적으로 **핫 리로드** 지원:
- Python 파일 수정 시 자동 재시작
- 템플릿/정적 파일 수정 시 즉시 반영

---

## 2. Docker 컨테이너화

### 2.1 Dockerfile 분석
**파일**: [Dockerfile](../../Dockerfile:1-10)

```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY main.py .
COPY templates ./templates
COPY static ./static

CMD exec gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app
```

#### 레이어 분석
1. **베이스 이미지**: `python:3.9-slim` (~150MB)
2. **작업 디렉토리**: `/app`
3. **의존성 설치**: `pip install` (캐싱 최적화)
4. **소스 복사**: `main.py`, `templates/`, `static/`
5. **실행 명령**: `gunicorn`

#### 최적화 포인트
- ✅ `--no-cache-dir`로 pip 캐시 제거 (이미지 크기 감소)
- ✅ `requirements.txt`를 먼저 복사하여 캐싱 활용
- ⚠️ `.dockerignore` 없음 (개선 필요)

**권장 `.dockerignore`**:
```
__pycache__/
*.pyc
.git/
.vscode/
docs/
*.md
.env
```

### 2.2 Docker 빌드 및 실행

#### 이미지 빌드
```bash
docker build -t eduverse:latest .

# 태깅
docker tag eduverse:latest eduverse:v1.0.0
```

#### 컨테이너 실행
```bash
# 기본 실행
docker run -p 8080:8080 eduverse:latest

# 환경 변수 전달
docker run -p 8080:8080 \
  -e FIREBASE_PROJECT_ID=my-python-65210-65c44 \
  eduverse:latest

# 백그라운드 실행
docker run -d -p 8080:8080 --name eduverse-app eduverse:latest

# 로그 확인
docker logs -f eduverse-app
```

#### 컨테이너 관리
```bash
# 중지
docker stop eduverse-app

# 재시작
docker restart eduverse-app

# 삭제
docker rm eduverse-app

# 이미지 삭제
docker rmi eduverse:latest
```

### 2.3 Docker Compose (선택적)
**파일**: `docker-compose.yml` (생성 권장)

```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8080:8080"
    environment:
      - FIREBASE_PROJECT_ID=my-python-65210-65c44
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**사용법**:
```bash
# 빌드 및 실행
docker-compose up -d

# 로그 확인
docker-compose logs -f

# 중지 및 삭제
docker-compose down
```

---

## 3. Google Cloud Platform 배포

### 3.1 Cloud Run 배포

#### app.yaml 설정
**파일**: [app.yaml](../../app.yaml:1-7)

```yaml
runtime: python312
handlers:
  - url: /static
    static_dir: static
  - url: /.*
    script: auto
```

**설정 설명**:
- **런타임**: Python 3.12 (최신 버전)
- **정적 파일**: `/static` URL은 `static/` 디렉토리에서 직접 서빙
- **동적 라우팅**: 나머지 모든 요청은 Flask 앱으로 전달

#### 배포 명령어
```bash
# GCP 로그인
gcloud auth login

# 프로젝트 설정
gcloud config set project my-python-65210-65c44

# Cloud Run 배포
gcloud run deploy eduverse \
  --source . \
  --region us-central1 \
  --allow-unauthenticated

# 또는 app.yaml 사용
gcloud app deploy
```

#### 배포 프로세스
1. 소스 코드 압축 및 업로드
2. Cloud Build에서 Dockerfile 빌드
3. 컨테이너 이미지 Container Registry에 저장
4. Cloud Run 서비스 생성/업데이트
5. HTTPS URL 자동 할당

**배포 결과**:
```
Service [eduverse] deployed to [https://eduverse-xxxxxxxxxx-uc.a.run.app]
```

### 3.2 Cloud Run 설정

#### 자동 스케일링
```bash
gcloud run services update eduverse \
  --min-instances 0 \
  --max-instances 10 \
  --concurrency 80
```

**설정 설명**:
- **min-instances**: 최소 인스턴스 수 (0 = 완전 서버리스)
- **max-instances**: 최대 인스턴스 수
- **concurrency**: 인스턴스당 동시 요청 수

#### 리소스 할당
```bash
gcloud run services update eduverse \
  --cpu 1 \
  --memory 512Mi \
  --timeout 300
```

**설정 설명**:
- **CPU**: 1 vCPU
- **메모리**: 512MB
- **타임아웃**: 300초 (Pyodide 로딩 고려)

#### 환경 변수 설정
```bash
gcloud run services update eduverse \
  --set-env-vars FIREBASE_PROJECT_ID=my-python-65210-65c44
```

### 3.3 커스텀 도메인 연결

#### 도메인 매핑
```bash
gcloud run domain-mappings create \
  --service eduverse \
  --domain eduverse.example.com \
  --region us-central1
```

#### SSL 인증서
Cloud Run은 **자동으로 SSL 인증서** 발급 (Let's Encrypt)

---

## 4. Firebase 설정

### 4.1 프로젝트 정보
- **프로젝트 ID**: `my-python-65210-65c44`
- **프로젝트 이름**: My Python 65210 65c44
- **리전**: 기본 (자동 할당)

### 4.2 Firestore 데이터베이스

#### 생성
```bash
# Firebase CLI 설치
npm install -g firebase-tools

# 로그인
firebase login

# 프로젝트 초기화
firebase init firestore

# 데이터베이스 생성 (콘솔에서도 가능)
```

#### 보안 규칙 설정
**파일**: `firestore.rules` (생성 권장)

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // 인증된 사용자만 접근 가능
    match /{document=**} {
      allow read, write: if request.auth != null;
    }

    // users 컬렉션 - 자신의 문서만
    match /users/{email} {
      allow read, write: if request.auth != null &&
                           request.auth.token.email == email;
    }

    // scenarios 컬렉션 - 읽기만 가능
    match /scenarios/{week} {
      allow read: if request.auth != null;
      allow write: if false;
    }
  }
}
```

**배포**:
```bash
firebase deploy --only firestore:rules
```

#### 인덱스 설정
**파일**: `firestore.indexes.json` (생성 권장)

```json
{
  "indexes": [
    {
      "collectionGroup": "classes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "instructorEmail", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "questions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "studentEmail", "order": "ASCENDING" },
        { "fieldPath": "isNotified", "order": "ASCENDING" },
        { "fieldPath": "isResolved", "order": "ASCENDING" }
      ]
    }
  ]
}
```

**배포**:
```bash
firebase deploy --only firestore:indexes
```

### 4.3 시나리오 데이터 업로드

#### upload_scenarios.py 사용
**파일**: [upload_scenarios.py](../../upload_scenarios.py)

```bash
# 시나리오 데이터 업로드
python upload_scenarios.py

# scenario.json → Firestore scenarios 컬렉션
```

---

## 5. CI/CD 파이프라인

### 5.1 GitHub Actions (권장)

#### 워크플로우 파일
**파일**: `.github/workflows/deploy.yml` (생성 권장)

```yaml
name: Deploy to Cloud Run

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: my-python-65210-65c44
          service_account_key: ${{ secrets.GCP_SA_KEY }}

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy eduverse \
            --source . \
            --region us-central1 \
            --allow-unauthenticated

      - name: Notify deployment
        run: echo "Deployment successful!"
```

#### Secret 설정
GitHub Repository Settings → Secrets:
- `GCP_SA_KEY`: GCP Service Account JSON 키

### 5.2 Cloud Build (GCP 네이티브)

#### cloudbuild.yaml
**파일**: `cloudbuild.yaml` (생성 권장)

```yaml
steps:
  # Docker 이미지 빌드
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/eduverse:$COMMIT_SHA', '.']

  # Container Registry에 푸시
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/eduverse:$COMMIT_SHA']

  # Cloud Run 배포
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'eduverse'
      - '--image'
      - 'gcr.io/$PROJECT_ID/eduverse:$COMMIT_SHA'
      - '--region'
      - 'us-central1'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'

images:
  - 'gcr.io/$PROJECT_ID/eduverse:$COMMIT_SHA'
```

#### 트리거 설정
```bash
gcloud builds triggers create github \
  --repo-name=EduVerse \
  --repo-owner=kimtaiseok \
  --branch-pattern="^master$" \
  --build-config=cloudbuild.yaml
```

---

## 6. 모니터링 및 로깅

### 6.1 Cloud Logging

#### 로그 확인
```bash
# 최근 로그 조회
gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=eduverse" \
  --limit 50 \
  --format json

# 에러 로그만 조회
gcloud logging read "resource.type=cloud_run_revision AND severity=ERROR" \
  --limit 20
```

#### 로그 스트리밍
```bash
gcloud logging tail "resource.type=cloud_run_revision" --format=json
```

### 6.2 Cloud Monitoring

#### 메트릭 확인
```bash
# 요청 수
gcloud monitoring time-series list \
  --filter='metric.type="run.googleapis.com/request_count"'

# 응답 시간
gcloud monitoring time-series list \
  --filter='metric.type="run.googleapis.com/request_latencies"'
```

#### 알림 설정 (콘솔)
1. Cloud Console → Monitoring → Alerting
2. Create Policy
3. 조건 설정:
   - 메트릭: Request latency
   - 임계값: 5초 초과
4. 알림 채널: 이메일, Slack 등

### 6.3 애플리케이션 로깅

#### Python 로깅 설정
**main.py에 추가 권장**:

```python
import logging
from google.cloud import logging as cloud_logging

# Cloud Logging 클라이언트
logging_client = cloud_logging.Client()
logging_client.setup_logging()

# 로거 설정
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# 로깅 예시
@app.route('/api/login', methods=['POST'])
def login():
    try:
        # ... 로직
        logger.info(f"User {email} logged in successfully")
        return jsonify({"status": "success"})
    except Exception as e:
        logger.error(f"Login failed for {email}: {e}")
        return jsonify({"status": "error"}), 500
```

---

## 7. 성능 최적화

### 7.1 CDN 활용
**Cloud CDN** 설정:
```bash
gcloud compute backend-services update eduverse-backend \
  --enable-cdn \
  --cache-mode=CACHE_ALL_STATIC
```

**캐싱 헤더** (main.py 추가):
```python
@app.after_request
def add_cache_headers(response):
    if request.path.startswith('/static/'):
        response.cache_control.max_age = 31536000  # 1년
        response.cache_control.public = True
    return response
```

### 7.2 이미지 최적화
```bash
# WebP 변환 (권장)
cwebp -q 80 office-bg.jpg -o office-bg.webp
cwebp -q 80 alex.png -o alex.webp

# HTML에서 사용
<picture>
  <source srcset="/static/images/office-bg.webp" type="image/webp">
  <img src="/static/images/office-bg.jpg" alt="Office Background">
</picture>
```

### 7.3 Pyodide 캐싱
**Service Worker** (권장):
```javascript
// service-worker.js
const CACHE_NAME = 'eduverse-v1';
const urlsToCache = [
  'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js',
  'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.asm.wasm',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache))
  );
});
```

---

## 8. 백업 및 복구

### 8.1 Firestore 백업

#### 자동 백업 설정
```bash
gcloud firestore backups schedules create \
  --database='(default)' \
  --recurrence=weekly \
  --retention=4w
```

#### 수동 백업
```bash
gcloud firestore export gs://eduverse-backups/$(date +%Y%m%d)
```

### 8.2 데이터 복원
```bash
gcloud firestore import gs://eduverse-backups/20251022
```

---

## 9. 비용 최적화

### 9.1 Cloud Run 비용
**요금 구조**:
- CPU: vCPU-초당 $0.00002400
- 메모리: GB-초당 $0.00000250
- 요청: 100만 요청당 $0.40

**월 예상 비용** (1000명 사용자 가정):
- CPU: ~$5
- 메모리: ~$2
- 요청: ~$1
- **총**: ~$8/월

### 9.2 Firestore 비용
**요금 구조**:
- 문서 읽기: 10만 건당 $0.06
- 문서 쓰기: 10만 건당 $0.18
- 문서 삭제: 10만 건당 $0.02
- 저장: GB당 $0.18/월

**월 예상 비용** (활발한 사용):
- 읽기: ~$10
- 쓰기: ~$5
- 저장: ~$2
- **총**: ~$17/월

### 9.3 최적화 전략
1. ✅ **캐싱**: 자주 조회되는 scenarios 클라이언트 캐싱
2. ✅ **배치 쓰기**: 여러 업데이트를 한 번에 처리
3. ✅ **최소 인스턴스 0**: 사용하지 않을 때 완전 종료
4. ⚠️ **쿼리 최적화**: 불필요한 필드 제외

---

## 10. 보안 체크리스트

### 프로덕션 배포 전 확인사항
- [ ] Firestore 보안 규칙 설정
- [ ] HTTPS 강제 (Cloud Run 기본 제공)
- [ ] 환경 변수로 민감 정보 관리
- [ ] CORS 설정 (필요 시)
- [ ] Rate Limiting (Cloud Armor)
- [ ] 백업 설정
- [ ] 모니터링 및 알림 설정
- [ ] 에러 로깅 설정

---

## 다음 단계

### 개선 권장사항
1. **CI/CD 파이프라인** 구축 (GitHub Actions 또는 Cloud Build)
2. **자동화된 테스트** 추가 (pytest)
3. **환경 변수 관리** (.env 파일 또는 Secret Manager)
4. **Firestore 보안 규칙** 강화
5. **성능 모니터링** 대시보드 구축
6. **백업 자동화** 설정

이상으로 EduVerse 프로젝트의 전체 분석을 완료했습니다.

← [06. 주요 기능 분석](./06_주요_기능_분석.md) | [README로 돌아가기](./README.md)
