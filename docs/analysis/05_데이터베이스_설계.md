# 05. 데이터베이스 설계

## Firestore 개요

### 데이터베이스 타입
- **NoSQL 문서 데이터베이스** (Document-oriented)
- **실시간 동기화** 지원
- **서버리스 자동 스케일링**

### Firebase 프로젝트
- **프로젝트 ID**: `my-python-65210-65c44`
- **리전**: 기본 (Google 자동 할당)
- **접근 방식**:
  - 서버: Firebase Admin SDK
  - 클라이언트: Firebase JavaScript SDK v9

---

## 컬렉션 구조 개요

```
Firestore Database
├── users/                        # 사용자 (문서 ID: 이메일)
├── scenarios/                    # 커리큘럼 (문서 ID: week_1, week_2, ...)
├── classes/                      # 수업 (문서 ID: 자동 생성)
├── questions/                    # 질문 (문서 ID: 자동 생성)
├── submission_logs/              # 제출 로그 (문서 ID: 자동 생성)
└── reflections/                  # 회고 (문서 ID: 자동 생성)
```

**총 컬렉션 수**: 6개

---

## 컬렉션 상세 분석

### 1. users 컬렉션

#### 문서 ID
`{email}` (예: `hong@example.com`)

#### 스키마
```javascript
{
  // 기본 정보
  name: string,                    // 사용자 이름
  email: string,                   // 이메일 (문서 ID와 동일)
  passwordHash: string,            // pbkdf2:sha256 해시
  password: string,                // [레거시] 평문 비밀번호 (마이그레이션 지원)
  role: "student" | "instructor",  // 역할

  // 학습 진행도 (학습자 전용)
  progress: {
    week: number,                  // 현재 주차 (1-12)
    cycle: number,                 // 현재 사이클 인덱스 (0부터 시작)
  },

  // 인트로 추적
  lastSeenIntroWeek: number,       // 마지막으로 본 주차 인트로
  seenCodingIntros: string[],      // 본 코딩 인트로 키 배열 (예: ["week1_cycle0", ...])

  // 클래스 소속
  classId?: string,                // 소속 클래스 ID (학습자만)

  // 실시간 코드 (학습자 전용)
  liveCode?: string,               // 현재 작성 중인 코드
  lastActive?: Timestamp,          // 마지막 활동 시간

  // 일시정지 상태
  pauseState?: {
    view: "task" | "briefing" | "lecture" | "dashboard",
    code?: string,                 // 일시정지 시점의 코드
  },
}
```

#### 예시 문서
```javascript
users/hong@example.com = {
  name: "홍길동",
  email: "hong@example.com",
  passwordHash: "$pbkdf2-sha256$29000$...",
  role: "student",
  progress: { week: 5, cycle: 3 },
  lastSeenIntroWeek: 5,
  seenCodingIntros: [
    "week1_cycle0",
    "week2_cycle1",
    "week3_cycle0"
  ],
  classId: "abc123xyz",
  liveCode: "def calculate_sum(a, b):\n    return a + b",
  lastActive: Timestamp(2025, 10, 22, 14, 30, 0),
  pauseState: {
    view: "lecture",
    code: "x = 10"
  }
}
```

#### 인덱스
- **기본 인덱스**: `email` (문서 ID)
- **복합 인덱스** (자동 생성):
  - `role` + `email`
  - `classId` + `email`

#### 쿼리 패턴
```javascript
// 특정 사용자 조회
db.collection('users').document(email).get()

// 특정 클래스 학생 목록 조회
db.collection('users').where('classId', '==', classId).get()

// 실시간 리스너 (클라이언트)
onSnapshot(doc(db, 'users', email), (snapshot) => { ... })
```

---

### 2. scenarios 컬렉션

#### 문서 ID
`week_{week_num}` (예: `week_1`, `week_2`, ..., `week_12`)

#### 스키마
```javascript
{
  week: number,                    // 주차 번호 (1-12)
  title: string,                   // 주차 제목
  cycles: [                        // 사이클 배열
    {
      title: string,               // 사이클 제목
      syntax_key: string,          // 문법 키 (config.js의 syntaxMap 참조)
      filename: string,            // 파일명
      starterCode: string,         // 시작 코드 (Monaco Editor에 로드)
      testCode: string,            // 테스트 코드 (assert 문)

      // Task (Alex)
      task: {
        character: "alex",
        subtitle: string,          // 소제목
        title: string,             // 제목
        content: string,           // HTML 포함 가능
      },

      // Briefing (Sena)
      briefing: {
        character: "sena",
        subtitle: string,
        title: string,
        content: string,
      },

      // Lecture (Prof. Kim)
      lecture: {
        character: "profKim",
        title: string,
        keyTakeaway: string,       // 핵심 요약
        sandboxCode?: string,      // 샌드박스 코드 (null 가능)
        sections: [
          {
            heading: string,       // 섹션 제목
            text: string,          // 설명 텍스트
            code?: string,         // 예제 코드 (null 가능)
          }
        ]
      },

      // Feedback
      feedback: {
        success: {
          character: "alex",
          subtitle: string,
          title: string,
          content: string,
        },
        failure_logical: {
          character: "sena",
          subtitle: string,
          title: string,
          content: string,        // {{ERROR_MESSAGE}} 플레이스홀더 포함
        },
        failure_runtime: {
          character: "sena",
          subtitle: string,
          title: string,
          content: string,
        }
      }
    }
  ]
}
```

#### 예시 문서 (축약)
```javascript
scenarios/week_1 = {
  week: 1,
  title: "신입사원 온보딩 및 개발 환경 구축",
  cycles: [
    {
      title: "오리엔테이션 및 파이썬 설치",
      syntax_key: "installation",
      filename: "check_python_version.py",
      starterCode: "import sys\nprint('파이썬 설치 확인!')\n...",
      testCode: "assert sys.version_info.major >= 3",
      task: { character: "alex", title: "LogiCore Tech에 오신 것을 환영합니다!", ... },
      briefing: { character: "sena", title: "첫 단추 채우기", ... },
      lecture: { character: "profKim", title: "교수님의 쪽지: 언어와 인터프리터", ... },
      feedback: { success: { ... }, failure_logical: { ... }, failure_runtime: { ... } }
    },
    // ... 더 많은 사이클
  ]
}
```

#### 데이터 소스
- **파일**: [scenario.json](../../scenario.json:1) (2,253 라인)
- **업로드**: [upload_scenarios.py](../../upload_scenarios.py) 스크립트 사용

#### 쿼리 패턴
```javascript
// 특정 주차 시나리오 조회
db.collection('scenarios').document('week_3').get()
```

---

### 3. classes 컬렉션

#### 문서 ID
자동 생성 (Firestore UUID)

#### 스키마
```javascript
{
  classId: string,                 // 문서 ID와 동일
  className: string,               // 수업명 (자동 생성: "[연도 학기] 과목명 (학과 분반)")
  details: {
    subject: string,               // 과목명
    year: string,                  // 연도
    semester: string,              // 학기
    department: string,            // 학과
    section: string,               // 분반
  },
  instructorEmail: string,         // 교수자 이메일
  inviteCode: string,              // 6자리 초대 코드 (대문자+숫자)
  students: string[],              // 학생 이메일 배열
  createdAt: Timestamp,            // 생성 시간
}
```

#### 예시 문서
```javascript
classes/abc123xyz = {
  classId: "abc123xyz",
  className: "[2025 1학기] Python 프로그래밍 (컴퓨터공학과 01분반)",
  details: {
    subject: "Python 프로그래밍",
    year: "2025",
    semester: "1학기",
    department: "컴퓨터공학과",
    section: "01"
  },
  instructorEmail: "prof@example.com",
  inviteCode: "A3B7X9",
  students: [
    "hong@example.com",
    "kim@example.com",
    "lee@example.com"
  ],
  createdAt: Timestamp(2025, 10, 1, 9, 0, 0)
}
```

#### 인덱스
- **복합 인덱스**:
  - `instructorEmail` + `createdAt` (내림차순)
  - `inviteCode` (단일)

#### 쿼리 패턴
```javascript
// 교수자의 클래스 목록 조회
db.collection('classes')
  .where('instructorEmail', '==', email)
  .orderBy('createdAt', 'desc')
  .get()

// 초대 코드로 클래스 검색
db.collection('classes')
  .where('inviteCode', '==', code)
  .limit(1)
  .get()

// 특정 클래스 상세 조회
db.collection('classes').document(classId).get()
```

---

### 4. questions 컬렉션

#### 문서 ID
자동 생성 (Firestore UUID)

#### 스키마
```javascript
{
  questionId: string,              // 문서 ID와 동일
  classId: string,                 // 소속 클래스
  studentEmail: string,            // 질문한 학생
  question: string,                // 질문 내용
  progress: {
    week: number,
    cycle: number,
  },
  characterContext: {
    character: "alex" | "sena" | "profKim",
    content: string,               // 질문 시점의 캐릭터 대사 (컨텍스트)
  },
  isResolved: boolean,             // 답변 완료 여부
  isNotified: boolean,             // 학생이 답변 확인 여부
  answer: string,                  // 교수자 답변
  createdAt: Timestamp,            // 질문 생성 시간
}
```

#### 예시 문서
```javascript
questions/q123xyz = {
  questionId: "q123xyz",
  classId: "abc123",
  studentEmail: "hong@example.com",
  question: "for 루프에서 인덱스를 어떻게 가져오나요?",
  progress: { week: 3, cycle: 2 },
  characterContext: {
    character: "sena",
    content: "range() 함수를 사용하여 반복 범위를 지정할 수 있습니다."
  },
  isResolved: true,
  isNotified: false,
  answer: "enumerate() 함수를 사용하세요! 예: for i, item in enumerate(my_list):",
  createdAt: Timestamp(2025, 10, 22, 14, 30, 0)
}
```

#### 인덱스
- **복합 인덱스**:
  - `studentEmail` + `createdAt` (내림차순)
  - `studentEmail` + `isNotified` + `isResolved` (실시간 리스너용)
  - `classId` + `createdAt` (내림차순)

#### 쿼리 패턴
```javascript
// 학생의 질문 목록 조회
db.collection('questions')
  .where('studentEmail', '==', email)
  .orderBy('createdAt', 'desc')
  .get()

// 미확인 답변 실시간 리스너
onSnapshot(
  query(
    collection(db, 'questions'),
    where('studentEmail', '==', email),
    where('isNotified', '==', false),
    where('isResolved', '==', true)
  ),
  (snapshot) => { ... }
)

// 특정 클래스의 모든 질문
db.collection('questions')
  .where('classId', '==', classId)
  .orderBy('createdAt', 'desc')
  .get()
```

---

### 5. submission_logs 컬렉션

#### 문서 ID
자동 생성 (Firestore UUID)

#### 스키마
```javascript
{
  logId: string,                   // 문서 ID와 동일
  studentEmail: string,            // 학생 이메일
  classId: string,                 // 소속 클래스
  week: number,                    // 제출한 주차
  cycle: number,                   // 제출한 사이클
  isSuccess: boolean,              // 제출 성공 여부
  error: string,                   // 에러 메시지 (실패 시)
  submittedAt: Timestamp,          // 제출 시간
}
```

#### 예시 문서
```javascript
submission_logs/log123 = {
  logId: "log123",
  studentEmail: "hong@example.com",
  classId: "abc123",
  week: 3,
  cycle: 5,
  isSuccess: false,
  error: "AssertionError: 출력 값이 예상과 다릅니다.",
  submittedAt: Timestamp(2025, 10, 22, 15, 45, 0)
}
```

#### 인덱스
- **복합 인덱스**:
  - `classId` + `week` + `cycle`
  - `studentEmail` + `submittedAt` (내림차순)

#### 쿼리 패턴
```javascript
// 특정 클래스의 모든 제출 로그
db.collection('submission_logs')
  .where('classId', '==', classId)
  .get()

// 특정 주차의 실패 로그 조회
db.collection('submission_logs')
  .where('classId', '==', classId)
  .where('week', '==', 3)
  .where('isSuccess', '==', false)
  .get()
```

---

### 6. reflections 컬렉션

#### 문서 ID
자동 생성 (Firestore UUID)

#### 스키마
```javascript
{
  reflectionId: string,            // 문서 ID와 동일
  studentEmail: string,            // 학생 이메일
  classId: string,                 // 소속 클래스
  week: number,                    // 회고 주차
  ratings: [                       // 주제별 평가
    {
      topic: string,               // 주제 (사이클 제목)
      comprehension: number,       // 이해도 (1-5)
      application: number,         // 적용도 (1-5)
    }
  ],
  feedback: {
    meaningful: string,            // 의미있었던 점
    difficult: string,             // 어려웠던 점
    curious: string,               // 궁금한 점
  },
  submittedAt: Timestamp,          // 제출 시간
}
```

#### 예시 문서
```javascript
reflections/ref123 = {
  reflectionId: "ref123",
  studentEmail: "hong@example.com",
  classId: "abc123",
  week: 3,
  ratings: [
    {
      topic: "if 조건문",
      comprehension: 5,
      application: 4
    },
    {
      topic: "while 루프",
      comprehension: 3,
      application: 2
    },
    {
      topic: "for 루프",
      comprehension: 4,
      application: 4
    }
  ],
  feedback: {
    meaningful: "조건문의 논리 구조를 이해하게 되었습니다.",
    difficult: "중첩 반복문을 사용할 때 헷갈렸습니다.",
    curious: "Python에는 switch 문이 없나요?"
  },
  submittedAt: Timestamp(2025, 10, 22, 18, 0, 0)
}
```

#### 인덱스
- **복합 인덱스**:
  - `classId` + `week`
  - `studentEmail` + `week` (오름차순)

#### 쿼리 패턴
```javascript
// 학생의 모든 회고 조회 (성장 분석용)
db.collection('reflections')
  .where('studentEmail', '==', email)
  .orderBy('week', 'asc')
  .get()

// 특정 클래스의 특정 주차 회고 조회
db.collection('reflections')
  .where('classId', '==', classId)
  .where('week', '==', 3)
  .get()
```

---

## 데이터 흐름 분석

### 1. 회원가입 흐름
```
클라이언트: POST /api/signup
  ↓
백엔드: 이메일 중복 확인
  ↓
백엔드: 비밀번호 해싱
  ↓
Firestore: users/{email} 문서 생성
  {
    name, email, passwordHash, role,
    progress: { week: 1, cycle: 0 },
    lastSeenIntroWeek: 0,
    seenCodingIntros: []
  }
```

### 2. 학습 진행 흐름
```
클라이언트: loadAndStartCycle(week, cycle)
  ↓
백엔드: GET /api/scenario/week/{week}
  ↓
Firestore: scenarios/week_{week} 조회
  ↓
클라이언트: weekData 저장 (state.js)
  ↓
클라이언트: Task → Briefing → Lecture → Coding
  ↓
클라이언트: Monaco Editor 코드 작성
  ↓
클라이언트: submitCode()
  ↓
클라이언트: Pyodide에서 테스트 실행
  ↓
클라이언트: POST /api/log/submission
  ↓
Firestore: submission_logs/{logId} 생성
  ↓
성공 시:
  클라이언트: POST /api/progress/update
  ↓
  Firestore: users/{email} 업데이트 (progress)
  ↓
  다음 사이클로 진행
```

### 3. 실시간 코드 모니터링 흐름
```
학습자: Monaco Editor에 코드 입력
  ↓
클라이언트: sendLiveCode() (1초 debounce)
  ↓
Firestore: users/{email} 업데이트 (liveCode, lastActive)
  ↓
교수자: Firestore onSnapshot 리스너
  ↓
교수자 화면: 실시간 코드 표시
```

### 4. Q&A 흐름
```
학습자: POST /api/question/ask
  ↓
Firestore: questions/{questionId} 생성
  {
    studentEmail, classId, question, progress,
    characterContext, isResolved: false,
    isNotified: false, answer: ""
  }
  ↓
교수자: Firestore 실시간 리스너 (monitor.js)
  ↓
교수자: 질문 확인 및 답변 작성
  ↓
교수자: POST /api/question/answer
  ↓
Firestore: questions/{questionId} 업데이트
  { answer, isResolved: true, isNotified: false }
  ↓
학습자: Firestore 실시간 리스너 (firebase.js)
  ↓
학습자: 알림 표시 ("새 답변이 도착했습니다!")
  ↓
학습자: 질문 모달 열기
  ↓
클라이언트: Firestore 업데이트 (isNotified: true)
```

---

## 보안 규칙 (권장)

### Firestore Security Rules
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // users 컬렉션
    match /users/{email} {
      // 자신의 문서만 읽기/쓰기 가능
      allow read, write: if request.auth != null && request.auth.token.email == email;
    }

    // scenarios 컬렉션
    match /scenarios/{week} {
      // 모든 인증된 사용자 읽기 가능
      allow read: if request.auth != null;
      // 쓰기 불가 (서버 사이드만)
      allow write: if false;
    }

    // classes 컬렉션
    match /classes/{classId} {
      // 교수자 또는 소속 학생만 읽기 가능
      allow read: if request.auth != null && (
        resource.data.instructorEmail == request.auth.token.email ||
        request.auth.token.email in resource.data.students
      );
      // 교수자만 생성/수정/삭제
      allow write: if request.auth != null && resource.data.instructorEmail == request.auth.token.email;
    }

    // questions 컬렉션
    match /questions/{questionId} {
      // 본인 또는 교수자만 읽기
      allow read: if request.auth != null;
      // 학생은 생성만, 교수자는 수정 가능
      allow create: if request.auth != null;
      allow update: if request.auth != null;
    }

    // submission_logs 컬렉션
    match /submission_logs/{logId} {
      // 본인 또는 교수자만 읽기
      allow read: if request.auth != null;
      // 생성만 가능
      allow create: if request.auth != null;
    }

    // reflections 컬렉션
    match /reflections/{reflectionId} {
      // 본인 또는 교수자만 읽기
      allow read: if request.auth != null;
      // 생성만 가능
      allow create: if request.auth != null;
    }
  }
}
```

**현재 상태**: 보안 규칙 미설정 (⚠️ 개선 필요)

---

## 데이터베이스 최적화

### 구현된 최적화
1. ✅ **복합 인덱스**: 자주 사용되는 쿼리 패턴에 대한 인덱스
2. ✅ **ArrayUnion**: 학생 추가 시 배열 중복 방지
3. ✅ **SERVER_TIMESTAMP**: 서버 시간 사용으로 시간 동기화
4. ✅ **Batch 처리**: 클래스 삭제 시 여러 문서 동시 업데이트

### 개선 가능 영역
1. ⚠️ **문서 크기 제한**: scenarios 문서가 큼 (주차당 분할 고려)
2. ⚠️ **쿼리 최적화**: 불필요한 필드 제외 (`select` 사용)
3. ⚠️ **캐싱**: 자주 조회되는 scenarios는 클라이언트 캐싱
4. ⚠️ **Pagination**: 로그 조회 시 페이징 처리

---

## 다음 단계
다음 문서에서는 주요 기능의 동작 방식을 상세히 분석합니다.

→ [06. 주요 기능 분석](./06_주요_기능_분석.md)
