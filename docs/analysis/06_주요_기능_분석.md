# 06. 주요 기능 분석

## 기능 개요

EduVerse는 크게 **5개의 주요 기능 영역**으로 구성됩니다:

1. **학습 시스템** - 시나리오 기반 Python 학습
2. **실시간 모니터링** - 교수자의 학습자 코드 모니터링
3. **클래스 관리** - 수업 생성, 참여, 관리
4. **Q&A 시스템** - 학습자-교수자 간 질의응답
5. **분석 및 리포팅** - 학습 데이터 시각화 및 분석

---

## 1. 학습 시스템

### 1.1 학습 흐름 개요

```
대시보드 → 주차 인트로 → Task → Briefing → Lecture →
  → Coding Intro → 코딩 화면 → 제출 → 피드백 → 다음 사이클
```

### 1.2 주차 시작 프로세스

#### 새 주차 진입 시
**트리거**: 로그인 시 `currentWeek > lastSeenIntroWeek`

**주차 인트로 모달** (learningModal.js):
```javascript
export function showWeeklyIntroModal() {
  const weekTitle = CURRICULUM[state.currentUser.progress.week];

  // 모달 렌더링
  weeklyIntroModal.innerHTML = `
    <div class="text-center">
      <h2 class="text-4xl font-bold text-yellow-300">
        Week ${state.currentUser.progress.week}
      </h2>
      <p class="text-2xl text-white mt-4">${weekTitle}</p>
      <p class="text-gray-300 mt-6">
        새로운 주차가 시작되었습니다! 준비되셨나요?
      </p>
      <button id="start-week-btn">시작하기</button>
    </div>
  `;

  weeklyIntroModal.classList.remove("hidden");
}
```

**로직**:
1. 로그인 시 백엔드에서 `showWeeklyIntro` 플래그 반환
2. 플래그가 `true`면 주차 인트로 모달 표시
3. "시작하기" 클릭 → 대시보드로 이동
4. `lastSeenIntroWeek` 업데이트 (서버)

### 1.3 사이클 학습 프로세스

#### Phase 1: Task (업무 지시)
**캐릭터**: Alex (팀장)
**목적**: 업무 맥락 제공

**렌더링** ([learningModal.js](../../static/learningModal.js)):
```javascript
function renderTaskModal(taskData) {
  const taskContent = document.getElementById("task-content");
  taskContent.innerHTML = `
    <div class="character-avatar">
      <img src="${IMAGE_URLS.alex}" alt="Alex" />
    </div>
    <h3 class="text-2xl font-bold text-yellow-300">${taskData.title}</h3>
    <p class="text-sm text-gray-400">${taskData.subtitle}</p>
    <div class="task-body">${taskData.content}</div>
    <button id="task-next-btn">다음</button>
  `;
}
```

#### Phase 2: Briefing (실무 팁)
**캐릭터**: Sena (선임)
**목적**: 구현 힌트 및 실무 조언

**특징**:
- "이전" 버튼으로 Task 복귀 가능
- "다음" 버튼으로 Lecture 진입

#### Phase 3: Lecture (개념 설명)
**캐릭터**: Prof. Kim (교수)
**목적**: 학술적 개념 설명

**구조**:
```javascript
{
  title: "교수님의 쪽지: 변수와 자료형",
  keyTakeaway: "변수는 데이터를 담는 상자입니다.",
  sections: [
    { heading: "핵심 개념", text: "...", code: "x = 10" },
    { heading: "활용 사례", text: "...", code: null },
    { heading: "주의점 및 팁", text: "...", code: null }
  ]
}
```

**샌드박스 기능**:
- 각 섹션의 코드를 바로 실행 가능
- Pyodide 사용하여 브라우저에서 즉시 실행
- 실행 결과를 모달 내에 표시

**Typed.js 효과**:
```javascript
sections.forEach((section, index) => {
  new Typed(`#typed-text-${index}`, {
    strings: [section.text],
    typeSpeed: 30,
    showCursor: false,
  });
});
```

#### Phase 4: Coding Intro (강의 회상)
**목적**: 처음 보는 사이클에만 강의 내용 요약 표시

**조건부 표시 로직**:
```javascript
const introKey = `week${currentWeek}_cycle${currentCycleIndex}`;
const seenIntros = currentUser.seenCodingIntros || [];

if (!seenIntros.includes(introKey)) {
  showCodingIntroModal();  // 인트로 표시
} else {
  showModal("dashboard");  // 바로 코딩 화면
}
```

**인트로 확인 기록**:
```javascript
await markCodingIntroAsSeen(introKey);
// → POST /api/coding-intro/seen
// → Firestore: users/{email}.seenCodingIntros에 추가
```

#### Phase 5: 코딩 화면
**구성 요소**:
1. **Monaco Editor** (코드 편집기)
2. **터미널 출력** (실행 결과)
3. **문법 레퍼런스** (우측 사이드바)
4. **액션 버튼** (실행, 제출, 다시 듣기)

**Monaco Editor 설정**:
```javascript
state.monacoEditor = monaco.editor.create(
  document.getElementById("monaco-editor"),
  {
    value: cycleData.starterCode,  // 시작 코드
    language: "python",
    theme: "vs-dark",
    automaticLayout: true,
    minimap: { enabled: false },
    fontSize: 14,
  }
);

// Live Code 전송 (1초 debounce)
state.monacoEditor.onDidChangeModelContent(() => {
  sendLiveCode(state.monacoEditor.getValue());
});
```

**문법 레퍼런스 표시**:
```javascript
const syntaxKeys = syntaxMap[cycleData.syntax_key] || [];
const syntaxItems = syntaxKeys.map(key => syntaxDb[key]);

syntaxReferenceDiv.innerHTML = syntaxItems.map(item => `
  <div class="syntax-item">
    <h4>${item.title}</h4>
    <p>${item.description}</p>
    <pre><code>${item.example}</code></pre>
  </div>
`).join('');
```

### 1.4 코드 실행 및 제출

#### "실행" 버튼
**동작**:
```javascript
async function handleRunCodeClick() {
  const code = state.monacoEditor.getValue();
  const result = await runPythonCode(code);

  const terminalOutput = document.getElementById("terminal-output");

  if (result.success) {
    terminalOutput.innerHTML = `<pre>${result.success}</pre>`;
  } else {
    terminalOutput.innerHTML = `<pre class="text-red-400">${result.error}</pre>`;
  }
}
```

**Pyodide 실행 엔진** ([codeEditor.js:76-106](../../static/codeEditor.js:76-106)):
```javascript
export async function runPythonCode(code) {
  // stdout/stderr 리디렉션
  await pyodide.runPythonAsync(`
    import io, sys
    sys.stdout = io.StringIO()
    sys.stderr = io.StringIO()
  `);

  // 코드 실행
  let result = await pyodide.runPythonAsync(code);
  let stdout = await pyodide.runPythonAsync("sys.stdout.getvalue()");
  let stderr = await pyodide.runPythonAsync("sys.stderr.getvalue()");

  if (stderr) return { error: stderr };

  return { success: stdout + (result?.toString() || "") };
}
```

#### "제출" 버튼
**동작**:
```javascript
async function submitCode() {
  const userCode = state.monacoEditor.getValue();
  const testCode = cycleData.testCode;
  const combinedCode = userCode + "\n\n" + testCode;

  // 테스트 실행
  const result = await runPythonCode(combinedCode);
  const isSuccess = !result.error;

  // 로그 저장
  await logSubmission(isSuccess, result.error || "");

  // 피드백 표시
  if (isSuccess) {
    showFeedbackModal("success");
  } else {
    // 에러 유형 판단
    const feedbackType = result.error.includes("AssertionError")
      ? "failure_logical"
      : "failure_runtime";
    showFeedbackModal(feedbackType, result.error);
  }
}
```

**로그 저장**:
```javascript
async function logSubmission(isSuccess, error) {
  await fetch("/api/log/submission", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      email: state.currentUser.email,
      classId: state.currentUser.classId,
      week: state.currentWeek,
      cycle: state.currentCycleIndex,
      isSuccess,
      error,
    }),
  });
}
```

### 1.5 피드백 및 진행

#### 피드백 모달
**성공 피드백** (Alex):
```javascript
{
  character: "alex",
  subtitle: "업무 완료 피드백",
  title: "훌륭합니다!",
  content: "<span class='text-green-300'>테스트를 통과했습니다.</span> 다음 업무로 넘어가죠."
}
```

**실패 피드백** (Sena):
```javascript
{
  character: "sena",
  subtitle: "문제 해결 지원",
  title: "조금만 더 생각해봐요!",
  content: "{{ERROR_MESSAGE}}라는 에러가 발생했어요. 다시 한번 확인해주시겠어요?"
}
```

**에러 메시지 삽입**:
```javascript
const errorMessage = error.split("\n").slice(-1)[0]; // 마지막 줄만
const content = feedbackData.content.replace("{{ERROR_MESSAGE}}", errorMessage);
```

#### 다음 사이클 진행
**성공 시**:
```javascript
async function advanceToNextCycle() {
  const nextCycleIndex = state.currentCycleIndex + 1;
  const totalCycles = state.weekData.cycles.length;

  if (nextCycleIndex < totalCycles) {
    // 다음 사이클로
    state.currentCycleIndex = nextCycleIndex;
    await updateProgress(state.currentWeek, nextCycleIndex);
    showModal("task");  // 다음 Task부터 시작
  } else {
    // 주차 완료 → 회고 모달
    showReflectionModal();
  }
}
```

### 1.6 주차 회고

#### 회고 모달 구조
```javascript
{
  week: 3,
  ratings: [
    { topic: "if 조건문", comprehension: 4, application: 3 },
    { topic: "while 루프", comprehension: 3, application: 2 },
    { topic: "for 루프", comprehension: 5, application: 4 }
  ],
  feedback: {
    meaningful: "조건문의 논리 구조를 이해하게 되었습니다.",
    difficult: "중첩 반복문이 어려웠습니다.",
    curious: "switch 문은 없나요?"
  }
}
```

**UI**:
- 각 사이클(주제)별 5점 척도 슬라이더
  - 이해도 (Comprehension)
  - 적용도 (Application)
- 자유 텍스트 입력
  - 의미있었던 점
  - 어려웠던 점
  - 궁금한 점

**제출 처리**:
```javascript
async function submitReflection() {
  const ratings = collectRatings();  // 슬라이더 값 수집
  const feedback = {
    meaningful: document.getElementById("meaningful-input").value,
    difficult: document.getElementById("difficult-input").value,
    curious: document.getElementById("curious-input").value,
  };

  await fetch("/api/log/reflection", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      email: state.currentUser.email,
      classId: state.currentUser.classId,
      week: state.currentWeek,
      ratings,
      feedback,
    }),
  });

  // 다음 주차로 진행
  const nextWeek = state.currentWeek + 1;
  await updateProgress(nextWeek, 0);
  showDashboardForCurrentUser();
}
```

---

## 2. 실시간 모니터링

### 2.1 교수자 모니터링 대시보드
**파일**: [templates/monitor.html](../../templates/monitor.html:1) + [static/monitor.js](../../static/monitor.js)

#### 기능 개요
1. **클래스 선택** - 드롭다운으로 모니터링할 클래스 선택
2. **학생 목록** - 현재 접속 중인 학생 표시 (lastActive 기준)
3. **실시간 코드 뷰** - 선택한 학생의 코드 실시간 표시
4. **진행 상황** - 각 학생의 현재 주차/사이클
5. **질문 알림** - 새로운 질문 도착 시 알림

#### 실시간 리스너 설정
```javascript
function setupRealtimeMonitoring(classId) {
  const classDocRef = doc(db, "classes", classId);

  // 클래스 정보 리스너
  onSnapshot(classDocRef, (snapshot) => {
    const classData = snapshot.data();
    const studentEmails = classData.students || [];
    renderStudentList(studentEmails);
  });
}

function renderStudentList(studentEmails) {
  studentEmails.forEach(email => {
    const userRef = doc(db, "users", email);

    // 각 학생의 실시간 리스너
    onSnapshot(userRef, (snapshot) => {
      const userData = snapshot.data();
      updateStudentCard({
        name: userData.name,
        email: userData.email,
        progress: userData.progress,
        liveCode: userData.liveCode,
        lastActive: userData.lastActive,
      });
    });
  });
}
```

#### 학생 카드 렌더링
```javascript
function updateStudentCard(studentData) {
  const card = document.getElementById(`student-${studentData.email}`);

  // 접속 상태 표시
  const isActive = isRecentlyActive(studentData.lastActive); // 5분 이내
  const statusClass = isActive ? "bg-green-500" : "bg-gray-500";

  card.innerHTML = `
    <div class="student-card">
      <div class="status-dot ${statusClass}"></div>
      <h3>${studentData.name}</h3>
      <p>Week ${studentData.progress.week}, Cycle ${studentData.progress.cycle + 1}</p>
      <button onclick="viewStudentCode('${studentData.email}')">
        코드 보기
      </button>
    </div>
  `;
}
```

#### 라이브 코드 뷰어
```javascript
function viewStudentCode(email) {
  const userRef = doc(db, "users", email);

  onSnapshot(userRef, (snapshot) => {
    const liveCode = snapshot.data().liveCode || "";

    // Monaco Editor (읽기 전용)
    const viewer = monaco.editor.create(
      document.getElementById("code-viewer"),
      {
        value: liveCode,
        language: "python",
        theme: "vs-dark",
        readOnly: true,  // 읽기 전용
        automaticLayout: true,
      }
    );
  });
}
```

### 2.2 질문 모니터링

#### 새 질문 알림
```javascript
function setupQuestionListener(classId) {
  const q = query(
    collection(db, "questions"),
    where("classId", "==", classId),
    where("isResolved", "==", false)
  );

  onSnapshot(q, (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === "added") {
        const questionData = change.doc.data();
        showQuestionNotification(questionData);
      }
    });
  });
}

function showQuestionNotification(questionData) {
  const notification = document.getElementById("question-notification");
  notification.innerHTML = `
    <div class="notification">
      <p><strong>${questionData.studentEmail}</strong>님의 질문</p>
      <p>${questionData.question.substring(0, 50)}...</p>
      <button onclick="answerQuestion('${questionData.questionId}')">
        답변하기
      </button>
    </div>
  `;
  notification.classList.remove("hidden");
}
```

#### 질문 답변 UI
```javascript
async function answerQuestion(questionId) {
  const answer = prompt("답변을 입력하세요:");
  if (!answer) return;

  await fetch("/api/question/answer", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ questionId, answer }),
  });

  alert("답변이 등록되었습니다!");
}
```

---

## 3. 클래스 관리

### 3.1 클래스 생성
**UI**: [index.html](../../templates/index.html) - Create Class Modal

**폼 구조**:
```html
<form id="create-class-form">
  <input name="subject" placeholder="과목명" required />
  <input name="year" placeholder="연도" value="2025" />
  <select name="semester">
    <option value="1학기">1학기</option>
    <option value="2학기">2학기</option>
  </select>
  <input name="department" placeholder="학과" />
  <input name="section" placeholder="분반" value="01" />
  <button type="submit">개설하기</button>
</form>
```

**제출 처리** ([ui.js](../../static/ui.js)):
```javascript
export async function handleCreateClassSubmit(e) {
  e.preventDefault();
  const formData = new FormData(e.target);
  const classDetails = {
    subject: formData.get("subject"),
    year: formData.get("year"),
    semester: formData.get("semester"),
    department: formData.get("department"),
    section: formData.get("section"),
  };

  const response = await fetch("/api/classes/create", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      instructorEmail: state.currentUser.email,
      classDetails,
    }),
  });

  const result = await response.json();
  if (response.ok) {
    alert(`수업이 개설되었습니다! 초대 코드: ${result.class.inviteCode}`);
    loadInstructorClasses();  // 클래스 목록 새로고침
  }
}
```

### 3.2 클래스 참여
**UI**: 학습자 대시보드 - Join Class 버튼

**참여 프로세스**:
```javascript
export function handleJoinClassClick() {
  const inviteCode = prompt("초대 코드를 입력하세요:");
  if (!inviteCode) return;

  fetch("/api/classes/join", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      inviteCode,
      studentEmail: state.currentUser.email,
    }),
  })
    .then(res => res.json())
    .then(result => {
      if (result.status === "success") {
        alert(result.message);
        state.currentUser.classId = result.classId;
        sessionStorage.setItem("currentUser", JSON.stringify(state.currentUser));
        showDashboardForCurrentUser();
      } else {
        alert(result.message);
      }
    });
}
```

### 3.3 클래스 삭제
**UI**: 교수자 대시보드 - 클래스 카드 삭제 버튼

**삭제 프로세스**:
```javascript
async function deleteClass(classId) {
  if (!confirm("정말 삭제하시겠습니까? 소속 학생들의 클래스 정보도 함께 삭제됩니다.")) {
    return;
  }

  const response = await fetch("/api/classes/delete", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      classId,
      instructorEmail: state.currentUser.email,
    }),
  });

  const result = await response.json();
  if (response.ok) {
    alert("삭제되었습니다.");
    loadInstructorClasses();
  } else {
    alert(result.message);
  }
}
```

---

## 4. Q&A 시스템

### 4.1 질문하기
**트리거**: 학습 중 "질문하기" 버튼 클릭

**UI**:
```html
<div id="question-modal" class="hidden">
  <h3>교수님께 질문하기</h3>
  <p>현재 위치: Week ${week}, Cycle ${cycle}</p>
  <textarea id="question-input" placeholder="질문을 입력하세요..."></textarea>
  <button id="submit-question-btn">질문 보내기</button>
</div>
```

**질문 제출**:
```javascript
async function submitQuestion() {
  const question = document.getElementById("question-input").value;
  if (!question.trim()) return;

  const characterContext = getCurrentCharacterContext();  // 현재 모달의 캐릭터 대사

  await fetch("/api/question/ask", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      email: state.currentUser.email,
      classId: state.currentUser.classId,
      question,
      progress: { week: state.currentWeek, cycle: state.currentCycleIndex },
      characterContext,
    }),
  });

  alert("질문이 전송되었습니다! 답변이 도착하면 알림을 드릴게요.");
  closeQuestionModal();
}
```

### 4.2 답변 수신 (실시간)
**리스너 설정** ([firebase.js:setupAnswerListener](../../static/firebase.js)):
```javascript
export function setupAnswerListener(notificationElement) {
  const q = query(
    collection(db, "questions"),
    where("studentEmail", "==", state.currentUser.email),
    where("isNotified", "==", false),
    where("isResolved", "==", true)
  );

  answerUnsubscribe = onSnapshot(q, (snapshot) => {
    snapshot.forEach((doc) => {
      const data = doc.data();

      // 알림 표시
      notificationElement.textContent = `새 답변: ${data.answer.substring(0, 50)}...`;
      notificationElement.classList.remove("hidden");

      // 알림 확인 처리
      updateDoc(doc.ref, { isNotified: true });
    });
  });
}
```

### 4.3 질문 목록 보기
**UI**: "내 질문" 버튼 → 모달

**데이터 로딩**:
```javascript
export async function showMyQuestions() {
  const response = await fetch(`/api/questions/my?email=${state.currentUser.email}`);
  const result = await response.json();

  const questionsContainer = document.getElementById("questions-list");
  questionsContainer.innerHTML = result.questions.map(q => `
    <div class="question-item">
      <p class="question-text">${q.question}</p>
      <p class="question-meta">Week ${q.progress.week}, Cycle ${q.progress.cycle + 1}</p>
      ${q.isResolved ? `
        <div class="answer">
          <p class="answer-label">답변:</p>
          <p class="answer-text">${q.answer}</p>
        </div>
      ` : `
        <p class="pending">답변 대기 중...</p>
      `}
    </div>
  `).join('');

  document.getElementById("my-questions-modal").classList.remove("hidden");
}
```

---

## 5. 분석 및 리포팅

### 5.1 클래스 분석 리포트
**파일**: [templates/report.html](../../templates/report.html:1) + [static/report.js](../../static/report.js)

#### 표시 데이터
1. **전체 성공률** - 제출 로그 기반
2. **주차별 성공률** - Chart.js 막대 그래프
3. **가장 실패가 많은 사이클** - Top 5
4. **학생별 진행도** - 테이블
5. **회고 분석** - 주제별 평균 이해도/적용도

#### 데이터 로딩
```javascript
async function loadClassAnalytics(classId) {
  const response = await fetch(`/api/analytics/class/${classId}`);
  const data = await response.json();

  // 전체 성공률
  document.getElementById("success-rate").textContent = `${data.successRate}%`;

  // 주차별 성공률 차트
  renderWeeklyChart(data.weeklySuccessRate);

  // 실패 패턴
  renderFailedCycles(data.mostFailedCycles);

  // 학생 진행도 테이블
  renderStudentProgress(data.studentProgress);

  // 회고 분석
  renderReflectionAnalysis(data.reflectionAnalysis);
}
```

#### Chart.js 차트 렌더링
```javascript
function renderWeeklyChart(weeklySuccessRate) {
  const ctx = document.getElementById("weekly-chart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(weeklySuccessRate),  // ["1주차", "2주차", ...]
      datasets: [{
        label: "성공률 (%)",
        data: Object.values(weeklySuccessRate),
        backgroundColor: "rgba(99, 102, 241, 0.6)",
        borderColor: "rgba(99, 102, 241, 1)",
        borderWidth: 1,
      }]
    },
    options: {
      scales: {
        y: { beginAtZero: true, max: 100 }
      }
    }
  });
}
```

### 5.2 개인 성장 트래킹
**파일**: [templates/growth.html](../../templates/growth.html:1) + [static/growth.js](../../static/growth.js)

#### 표시 데이터
1. **주차별 이해도 추이** - Line Chart
2. **주차별 적용도 추이** - Line Chart
3. **주차별 회고 요약** - 카드 형식

#### 데이터 로딩
```javascript
async function loadGrowthData() {
  const response = await fetch(`/api/analytics/my-growth?email=${currentUser.email}`);
  const data = await response.json();

  // 주차별 평균 이해도/적용도 계산
  const growthData = data.data.map(reflection => {
    const avgComprehension = average(reflection.ratings.map(r => r.comprehension));
    const avgApplication = average(reflection.ratings.map(r => r.application));

    return {
      week: reflection.week,
      weekTitle: reflection.weekTitle,
      comprehension: avgComprehension,
      application: avgApplication,
      feedback: reflection.feedback,
    };
  });

  renderGrowthChart(growthData);
  renderReflectionCards(growthData);
}
```

#### 성장 차트 렌더링
```javascript
function renderGrowthChart(growthData) {
  const ctx = document.getElementById("growth-chart").getContext("2d");
  new Chart(ctx, {
    type: "line",
    data: {
      labels: growthData.map(d => `Week ${d.week}`),
      datasets: [
        {
          label: "이해도",
          data: growthData.map(d => d.comprehension),
          borderColor: "rgba(34, 197, 94, 1)",
          backgroundColor: "rgba(34, 197, 94, 0.1)",
        },
        {
          label: "적용도",
          data: growthData.map(d => d.application),
          borderColor: "rgba(59, 130, 246, 1)",
          backgroundColor: "rgba(59, 130, 246, 0.1)",
        }
      ]
    },
    options: {
      scales: {
        y: { beginAtZero: true, max: 5 }
      }
    }
  });
}
```

---

## 다음 단계
다음 문서에서는 배포 및 인프라를 상세히 분석합니다.

→ [07. 배포 및 인프라](./07_배포_및_인프라.md)
