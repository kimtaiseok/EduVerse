# 04. 프론트엔드 분석

## 프론트엔드 아키텍처

### 전체 구조
```
┌─────────────────────────────────────────────────────────┐
│                  index.html (메인 셸)                       │
│  ├─ 인증 컨테이너                                           │
│  ├─ 대시보드 (플래너 스타일)                                 │
│  ├─ 학습 모달 (Task, Briefing, Lecture, Coding)            │
│  └─ 부가 기능 (Q&A, 클래스 참여, 회고)                        │
└─────────────────────────────────────────────────────────┘
         │
         ├─ main.js (애플리케이션 초기화)
         │   ├─ state.js (전역 상태)
         │   ├─ auth.js (로그인/회원가입)
         │   ├─ ui.js (뷰 전환, UI 업데이트)
         │   ├─ learningModal.js (모달 로직)
         │   ├─ codeEditor.js (Pyodide, Monaco)
         │   ├─ firebase.js (실시간 DB)
         │   └─ config.js (상수)
         │
         ├─ monitor.html + monitor.js (교수자 모니터링)
         ├─ report.html + report.js (분석 리포트)
         └─ growth.html + growth.js (성장 트래킹)
```

---

## ES6 모듈 구조

### 모듈 의존성 그래프
```
main.js
├── state.js (상태)
├── auth.js
│   └── state.js
├── ui.js
│   ├── state.js
│   └── config.js
├── learningModal.js
│   ├── state.js
│   ├── config.js
│   ├── firebase.js
│   └── codeEditor.js
├── codeEditor.js
│   ├── state.js
│   └── firebase.js
├── firebase.js
│   ├── state.js
│   └── firebase-config.js
└── config.js (독립)
```

---

## 주요 모듈 분석

### 1. main.js - 애플리케이션 진입점
**파일**: [static/main.js](../../static/main.js:1-324)
**라인 수**: 324

#### 주요 함수

##### 1.1 `loadAndStartCycle(week, cycleIndex, resumeState)`
**위치**: [main.js:40-61](../../static/main.js:40-61)
**역할**: 특정 주차/사이클의 학습 콘텐츠 로드

```javascript
export async function loadAndStartCycle(week, cycleIndex, resumeState = null) {
  try {
    const response = await fetch(`/api/scenario/week/${week}`);
    if (!response.ok) {
      if (response.status === 404) {
        return showReflectionModal(true);  // 주차 종료 → 회고 모달
      }
      throw new Error(`시나리오 로딩 실패: ${response.status}`);
    }
    state.weekData = await response.json();
    state.currentWeek = week;
    state.currentCycleIndex = cycleIndex;
    await proceedToCycle(resumeState);
  } catch (error) {
    console.error("Failed to load and start cycle:", error);
    alert(`학습 데이터를 불러오는 중 오류가 발생했습니다: ${error.message}`);
    showDashboardForCurrentUser();
  }
}
```

##### 1.2 `initializeApp()`
**위치**: [main.js:125-193](../../static/main.js:125-193)
**역할**: 앱 초기화 (자동 로그인, Firestore 리스너 설정)

**초기화 흐름**:
1. 문법 DB 로드 (`syntax.json`)
2. Firebase 초기화
3. SessionStorage에서 사용자 정보 확인
4. 자동 로그인 시도
5. 클래스 정보 조회 (있는 경우)
6. 주차 인트로 표시 여부 확인
7. 이벤트 리스너 설정

**자동 로그인 로직**:
```javascript
const savedUserJSON = sessionStorage.getItem("currentUser");
if (savedUserJSON) {
  const savedUser = JSON.parse(savedUserJSON);
  const res = await fetch("/api/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      email: savedUser.email,
      password: savedUser.password,  // ⚠️ 평문 저장
    }),
  });
  // ... 성공 시 대시보드 표시
}
```

##### 1.3 `setupEventListeners()`
**위치**: [main.js:195-315](../../static/main.js:195-315)
**역할**: 모든 버튼 클릭 이벤트 연결

**주요 이벤트**:
- 로그인/회원가입 폼 제출
- 로그아웃 버튼
- "학습 시작" 버튼
- 질문하기 버튼
- 성장 기록 보기
- 클래스 참여/생성 버튼

---

### 2. state.js - 전역 상태 관리
**파일**: [static/state.js](../../static/state.js:1-18)
**라인 수**: 18

```javascript
export let state = {
  currentUser: null,              // 현재 로그인 사용자
  currentWeek: 1,                 // 현재 학습 주차
  currentCycleIndex: 0,           // 현재 사이클 인덱스
  currentModalType: null,         // 현재 표시 중인 모달
  previousModalType: null,        // 이전 모달 (뒤로가기용)
  weekData: null,                 // 로드된 주차 데이터
  syntaxDb: null,                 // 문법 레퍼런스 DB
  classes: [],                    // 교수자의 클래스 목록
  monacoEditor: null,             // 데스크톱 에디터 인스턴스
  monacoEditorMobile: null,       // 모바일 에디터 인스턴스
};
```

**패턴**: Centralized State (단일 진실 공급원)
**장점**: 모든 모듈이 동일한 상태 참조
**단점**: 불변성 보장 없음 (Vue/React와 달리 직접 수정)

---

### 3. auth.js - 인증 로직
**파일**: [static/auth.js](../../static/auth.js:1-88)
**라인 수**: 88

#### 주요 함수

##### 3.1 `handleLoginSubmit(e)`
**역할**: 로그인 폼 제출 처리

```javascript
export async function handleLoginSubmit(e) {
  e.preventDefault();
  const formData = new FormData(e.target);
  const email = formData.get("email");
  const password = formData.get("password");

  try {
    const response = await fetch("/api/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });
    const result = await response.json();

    if (response.ok) {
      state.currentUser = result.user;
      state.currentUser.password = password;  // ⚠️ 재인증용 저장
      sessionStorage.setItem("currentUser", JSON.stringify(state.currentUser));
      return true;  // 성공
    } else {
      // 에러 메시지 표시
      return false;
    }
  } catch (error) {
    console.error("Login error:", error);
    return false;
  }
}
```

##### 3.2 `logout()`
**역할**: 로그아웃 및 상태 초기화

```javascript
export function logout() {
  state.currentUser = null;
  sessionStorage.removeItem("currentUser");
  showView("auth-container");
}
```

---

### 4. ui.js - UI 컴포넌트 관리
**파일**: [static/ui.js](../../static/ui.js)

#### 주요 함수

##### 4.1 `showView(viewId)`
**역할**: 뷰 전환 (인증 화면 ↔ 대시보드 ↔ 교수자 화면)

```javascript
export function showView(viewId) {
  const views = [
    "loading-indicator",
    "auth-container",
    "start-screen",
    "instructor-dashboard",
    "dashboard"
  ];

  views.forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      if (id === viewId) {
        element.classList.remove("hidden");
      } else {
        element.classList.add("hidden");
      }
    }
  });
}
```

##### 4.2 `updateDashboardUI(cycleData)`
**역할**: 대시보드에 현재 사이클 정보 표시

**업데이트 항목**:
- 주차 제목
- 사이클 제목
- 시작 버튼 텍스트
- 학습 로그

##### 4.3 `showDashboardForCurrentUser()`
**역할**: 사용자 역할에 따라 적절한 대시보드 표시

```javascript
export function showDashboardForCurrentUser() {
  if (!state.currentUser) return;

  if (state.currentUser.role === "instructor") {
    showInstructorDashboard();
  } else {
    showStudentDashboard();
  }
}
```

---

### 5. learningModal.js - 학습 모달 로직
**파일**: [static/learningModal.js](../../static/learningModal.js)

#### 모달 타입
1. **task**: 업무 지시 (Alex)
2. **briefing**: 실무 팁 (Sena)
3. **lecture**: 개념 설명 (Prof. Kim)
4. **dashboard**: 코딩 화면 (Monaco Editor)
5. **weeklyIntro**: 주차 시작 인트로
6. **codingIntro**: 강의 회상 인트로

#### 주요 함수

##### 5.1 `showModal(modalType)`
**역할**: 지정된 타입의 모달 표시

```javascript
export function showModal(modalType) {
  state.previousModalType = state.currentModalType;
  state.currentModalType = modalType;

  const cycleData = state.weekData.cycles[state.currentCycleIndex];

  switch (modalType) {
    case "task":
      renderTaskModal(cycleData.task);
      break;
    case "briefing":
      renderBriefingModal(cycleData.briefing);
      break;
    case "lecture":
      renderLectureModal(cycleData.lecture);
      break;
    case "dashboard":
      showView("dashboard");
      updateDashboardUI(cycleData);
      break;
  }
}
```

##### 5.2 `handleAction(action)`
**역할**: 모달 내 버튼 클릭 처리 (다음/이전/시작 코딩)

**액션 타입**:
- `next_task`: 다음 모달로 이동
- `prev_task`: 이전 모달로 이동
- `start_coding`: 코딩 화면으로 전환 (인트로 확인 로직 포함)
- `return_to_dashboard`: 대시보드로 복귀

**코딩 시작 로직** (인트로 확인):
```javascript
case "start_coding":
  const introKey = `week${state.currentWeek}_cycle${state.currentCycleIndex}`;
  const seenIntros = state.currentUser.seenCodingIntros || [];

  if (!seenIntros.includes(introKey)) {
    // 처음 보는 사이클 → 인트로 표시
    showCodingIntroModal();
  } else {
    // 이미 본 사이클 → 바로 코딩 화면
    showModal("dashboard");
  }
  break;
```

##### 5.3 `renderLectureModal(lectureData)`
**역할**: 교수님 강의 모달 렌더링 (섹션별 코드 샌드박스 포함)

**강의 구조**:
```javascript
{
  character: "profKim",
  title: "교수님의 쪽지: 변수와 자료형",
  keyTakeaway: "변수는 데이터를 담는 상자입니다.",
  sections: [
    {
      heading: "핵심 개념",
      text: "변수는...",
      code: "x = 10\nprint(x)"
    },
    {
      heading: "활용 사례",
      text: "...",
      code: null
    }
  ]
}
```

**Typed.js 타이핑 효과**:
```javascript
new Typed(`#typed-text-${index}`, {
  strings: [section.text],
  typeSpeed: 30,
  showCursor: false,
});
```

---

### 6. codeEditor.js - 코드 실행 엔진
**파일**: [static/codeEditor.js](../../static/codeEditor.js)

#### 주요 함수

##### 6.1 `initializePyodide(loadingIndicator, loadingText)`
**역할**: Pyodide 및 Monaco Editor 초기화

```javascript
export function initializePyodide(loadingIndicator, loadingText) {
  return new Promise((resolve, reject) => {
    (async () => {
      if (typeof loadPyodide === "undefined") {
        throw new Error("Pyodide 라이브러리를 로드할 수 없습니다.");
      }

      pyodide = await loadPyodide();

      require.config({
        paths: { vs: "https://cdnjs.../monaco-editor/0.44.0/min/vs" },
        "vs/nls": { availableLanguages: { "*": "ko" } },
      });

      require(["vs/editor/editor.main"], () => {
        loadingIndicator.classList.add("hidden");
        resolve();
      });
    })();
  });
}
```

##### 6.2 `runPythonCode(code)`
**역할**: Pyodide에서 Python 코드 실행

```javascript
export async function runPythonCode(code) {
  if (!pyodide) {
    return { error: "오류: Python 실행 환경이 준비되지 않았습니다." };
  }

  try {
    // stdout/stderr 리디렉션
    await pyodide.runPythonAsync(
      `import io, sys; sys.stdout = io.StringIO(); sys.stderr = io.StringIO();`
    );

    // 코드 실행
    let result = await pyodide.runPythonAsync(code);
    let stdout = await pyodide.runPythonAsync("sys.stdout.getvalue()");
    let stderr = await pyodide.runPythonAsync("sys.stderr.getvalue()");

    if (stderr) return { error: stderr };

    let output = stdout;
    if (result !== undefined && result !== null) {
      output += result.toString();
    }

    return { success: output };
  } catch (error) {
    return { error: error.message };
  }
}
```

##### 6.3 `setupDashboardFromTemplate()`
**역할**: Monaco Editor 인스턴스 생성 (데스크톱 + 모바일)

```javascript
export async function setupDashboardFromTemplate() {
  const cycleData = state.weekData.cycles[state.currentCycleIndex];

  // 데스크톱 에디터
  if (!state.monacoEditor) {
    state.monacoEditor = monaco.editor.create(
      document.getElementById("monaco-editor"),
      {
        value: cycleData.starterCode,
        language: "python",
        theme: "vs-dark",
        automaticLayout: true,
      }
    );

    // Live Code 전송
    state.monacoEditor.onDidChangeModelContent(() => {
      sendLiveCode(state.monacoEditor.getValue());
    });
  }

  // 모바일 에디터 (동일 로직)
  // ...
}
```

##### 6.4 `submitCode()`
**역할**: 코드 제출 및 테스트 실행

**실행 흐름**:
1. 사용자 코드 + 테스트 코드 합치기
2. Pyodide에서 실행
3. 성공/실패 판정
4. Firestore에 로그 저장
5. 피드백 모달 표시
6. 성공 시 다음 사이클로 진행

```javascript
async function submitCode() {
  const userCode = state.monacoEditor.getValue();
  const cycleData = state.weekData.cycles[state.currentCycleIndex];
  const testCode = cycleData.testCode;
  const combinedCode = userCode + "\n\n" + testCode;

  const result = await runPythonCode(combinedCode);
  const isSuccess = !result.error;

  // 로그 저장
  await logSubmission(isSuccess, result.error || "");

  if (isSuccess) {
    showFeedbackModal("success");
    advanceToNextCycle();
  } else {
    showFeedbackModal("failure");
  }
}
```

---

### 7. firebase.js - 실시간 데이터 동기화
**파일**: [static/firebase.js](../../static/firebase.js)

#### 주요 함수

##### 7.1 `sendLiveCode(code)` (Debounced)
**역할**: 교수자에게 실시간 코드 전송

```javascript
export const sendLiveCode = debounce(async (code) => {
  if (!state.currentUser || state.currentUser.role !== "student" || !db) return;

  try {
    const userRef = doc(db, "users", state.currentUser.email);
    await updateDoc(userRef, {
      liveCode: code,
      lastActive: serverTimestamp(),
    });
  } catch (err) {
    console.error("Live code update failed:", err);
  }
}, 1000);  // 1초 디바운스
```

**디바운스 함수**:
```javascript
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}
```

##### 7.2 `setupAnswerListener(notificationElement)`
**역할**: 교수자 답변 실시간 수신

```javascript
export function setupAnswerListener(notificationElement) {
  if (!state.currentUser || !db) return;

  const q = query(
    collection(db, "questions"),
    where("studentEmail", "==", state.currentUser.email),
    where("isNotified", "==", false),
    where("isResolved", "==", true)
  );

  answerUnsubscribe = onSnapshot(q, (snapshot) => {
    snapshot.forEach((doc) => {
      const data = doc.data();

      // 알림 표시
      notificationElement.textContent = `새 답변: ${data.answer.substring(0, 50)}...`;
      notificationElement.classList.remove("hidden");

      // isNotified = true로 업데이트
      updateDoc(doc.ref, { isNotified: true });
    });
  });
}
```

---

### 8. config.js - 설정 및 상수
**파일**: [static/config.js](../../static/config.js:1-79)

#### 상수 정의

##### 8.1 이미지 URL
```javascript
export const IMAGE_URLS = {
  officeBg: "/static/images/office-bg.jpg",
  lectureBg: "/static/images/lecture-bg.jpg",
  alex: "/static/images/alex.png",
  sena: "/static/images/sena.png",
  profKim: "/static/images/prof-kim.png",
  userAvatar: "/static/images/user-avatar.png",
};
```

##### 8.2 커리큘럼 맵
```javascript
export const CURRICULUM = {
  1: "신입사원 온보딩 및 개발 환경 구축",
  2: "데이터 기본기: 변수, 자료형, 연산자",
  3: "흐름 제어: 조건과 반복",
  // ... 12주까지
};
```

##### 8.3 문법 키 매핑
```javascript
export const syntaxMap = {
  installation: ["variables", "data_types"],
  print_statement: ["print_function"],
  if_statement: ["if_statement", "operators"],
  for_loop: ["for_in_loop", "range_function", "list_data_structure"],
  // ...
};
```

**용도**: 사이클의 `syntax_key`에 해당하는 문법 레퍼런스 표시

---

## HTML 템플릿 구조

### index.html - 메인 인터페이스
**파일**: [templates/index.html](../../templates/index.html:1-592)
**라인 수**: 592

#### 주요 섹션

##### 1. 로딩 인디케이터
```html
<div id="loading-indicator" class="...">
  <p id="loading-text">파이썬 실행 환경을 준비 중입니다...</p>
</div>
```

##### 2. 인증 컨테이너
```html
<div id="auth-container" class="hidden">
  <form id="login-form">
    <!-- 이메일, 비밀번호 입력 -->
  </form>
  <form id="signup-form" class="hidden">
    <!-- 이름, 이메일, 비밀번호, 역할 선택 -->
  </form>
</div>
```

##### 3. 학습자 대시보드 (플래너 스타일)
```html
<div id="start-screen" class="hidden">
  <header>
    <h1>My First Planner</h1>
    <span id="user-info"></span>
    <button id="logout-btn">로그아웃</button>
  </header>

  <div id="today-task-widget">
    <!-- 오늘의 학습 과제 -->
  </div>

  <button id="start-task-btn">
    <!-- 학습 시작 버튼 -->
  </button>

  <div id="learning-log">
    <!-- 학습 로그 -->
  </div>
</div>
```

##### 4. 교수자 대시보드
```html
<div id="instructor-dashboard" class="hidden">
  <div id="class-list">
    <!-- 클래스 목록 -->
  </div>
  <button id="create-class-btn">새 수업 개설</button>
</div>
```

##### 5. 학습 모달들
```html
<!-- Task 모달 -->
<div id="task-modal" class="modal hidden">
  <div id="task-content"></div>
  <button id="task-next-btn">다음</button>
</div>

<!-- Briefing 모달 -->
<div id="briefing-modal" class="modal hidden">
  <div id="briefing-content"></div>
  <button id="briefing-prev-btn">이전</button>
  <button id="briefing-next-btn">다음</button>
</div>

<!-- Lecture 모달 -->
<div id="lecture-modal" class="modal hidden">
  <div id="lecture-content"></div>
  <button id="lecture-prev-btn">이전</button>
  <button id="start-coding-btn">코딩 시작</button>
</div>
```

##### 6. 코딩 대시보드
```html
<div id="dashboard" class="hidden">
  <!-- 데스크톱 레이아웃 -->
  <div class="desktop-layout">
    <div id="monaco-editor"></div>
    <div id="terminal-output"></div>
    <button id="run-code-btn">실행</button>
    <button id="submit-code-btn">제출</button>
  </div>

  <!-- 모바일 레이아웃 (탭) -->
  <div class="mobile-layout">
    <div id="tab-editor"></div>
    <div id="tab-terminal"></div>
  </div>
</div>
```

---

## CSS 스타일링

### Tailwind 유틸리티 클래스 패턴

#### 레이아웃
- `flex`, `flex-col`, `items-center`, `justify-center`
- `grid`, `grid-cols-1`, `lg:grid-cols-3`
- `hidden`, `block`, `inline-block`

#### 색상 (다크 테마)
- 배경: `bg-gray-900`, `bg-gray-800`, `bg-gray-700`
- 텍스트: `text-white`, `text-gray-300`, `text-yellow-300`
- 강조: `text-indigo-400`, `text-green-400`, `text-red-400`

#### 반응형 브레이크포인트
- `md:` (≥768px)
- `lg:` (≥1024px)

#### 애니메이션
- `animate-pulse` (학습 시작 버튼)
- `transition-transform`, `hover:scale-105`

### 커스텀 CSS
**파일**: [static/style.css](../../static/style.css)

**주요 스타일**:
- `.planner-widget`: 플래너 스타일 위젯 배경
- `.font-planner`: 손글씨 폰트
- 모달 오버레이 및 애니메이션

---

## 프론트엔드 데이터 흐름

### 1. 초기 로딩 플로우
```
페이지 로드
  ↓
Pyodide 초기화 (3-5초)
  ↓
Monaco Editor 로드
  ↓
SessionStorage 확인
  ↓
자동 로그인 시도
  ↓
Firebase 실시간 리스너 설정
  ↓
대시보드 표시
```

### 2. 학습 시작 플로우
```
"학습 시작" 클릭
  ↓
일시정지 상태 확인
  ├─ 있음 → 복원 + API 호출
  └─ 없음 → 현재 진행도에서 시작
  ↓
/api/scenario/week/{week} 호출
  ↓
Task 모달 표시
  ↓
사용자 "다음" 클릭
  ↓
Briefing 모달
  ↓
사용자 "다음" 클릭
  ↓
Lecture 모달
  ↓
사용자 "코딩 시작" 클릭
  ├─ 첫 방문 → Coding Intro 표시
  └─ 재방문 → 코딩 화면 바로 표시
  ↓
Monaco Editor에 starter code 로드
  ↓
사용자 코딩
  ↓
"제출" 클릭
  ↓
Pyodide에서 테스트 실행
  ↓
결과에 따라 피드백 모달
  ├─ 성공 → 다음 사이클로 진행
  └─ 실패 → 재시도
```

### 3. 실시간 모니터링 플로우
```
학습자: Monaco Editor에 코드 입력
  ↓
1초 debounce
  ↓
Firestore 업데이트 (liveCode, lastActive)
  ↓
교수자: Firestore onSnapshot 리스너
  ↓
실시간으로 학습자 코드 표시
```

---

## 모바일 최적화

### 반응형 전략
1. **Tailwind 브레이크포인트**: `md:`, `lg:` 사용
2. **모바일 탭 UI**: 코드 에디터 ↔ 터미널 전환
3. **터치 최적화**: 큰 버튼, 충분한 패딩

### 모바일 전용 코드
```javascript
function setupMobileTabs() {
  const tabButtons = document.querySelectorAll(".mobile-tab-btn");

  tabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const target = btn.dataset.tab;

      // 탭 전환
      document.querySelectorAll(".mobile-tab-content").forEach((content) => {
        content.classList.toggle("hidden", content.id !== target);
      });
    });
  });
}
```

---

## 성능 최적화

### 구현된 최적화
1. ✅ **Debounce**: Live Code 전송 1초 제한
2. ✅ **비동기 로딩**: Pyodide, Monaco 비동기 초기화
3. ✅ **지연 렌더링**: 모달은 표시 시점에 렌더링
4. ✅ **Firestore 인덱싱**: 복합 쿼리 최적화

### 개선 가능 영역
1. ⚠️ **Code Splitting**: script.js (1,874 라인) 분할
2. ⚠️ **이미지 최적화**: WebP 변환, lazy loading
3. ⚠️ **번들링**: 로컬 번들링으로 CDN 의존성 제거
4. ⚠️ **Service Worker**: 오프라인 지원 및 캐싱

---

## 다음 단계
다음 문서에서는 Firestore 데이터베이스 설계를 상세히 분석합니다.

→ [05. 데이터베이스 설계](./05_데이터베이스_설계.md)
