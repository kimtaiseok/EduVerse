# 08. 코드 평가 시스템 분석

## 개요

EduVerse는 학습자가 작성한 Python 코드를 **자동으로 평가**하여 합격/불합격을 판정합니다. 이 문서는 코드 평가 시스템의 작동 방식과 구현 방법을 상세히 설명합니다.

---

## 1. 합격 판단 기준

### 1.1 기본 원리

**Python의 `assert` 문을 사용한 자동 테스트**

```python
# 학습자 코드
service_name = "LogiCore"
concurrent_users = 100
is_active = True

# 테스트 코드 (시나리오에 정의됨)
assert 'service_name' in locals() and service_name == 'LogiCore', \
    "service_name 변수에 'LogiCore' 문자열을 할당해야 합니다."
assert 'concurrent_users' in locals() and concurrent_users == 100, \
    "concurrent_users 변수에 숫자 100을 할당해야 합니다."
assert 'is_active' in locals() and is_active is True, \
    "is_active 변수에 불리언 값 True를 할당해야 합니다."
```

**판정 로직**:
- ✅ **합격**: 모든 assert 문이 통과 (예외 없음)
- ❌ **불합격**: 하나라도 AssertionError 또는 다른 예외 발생

### 1.2 테스트 코드 작성 패턴

#### 패턴 1: 변수 존재 및 값 확인
```python
assert 'variable_name' in locals(), "변수가 선언되지 않았습니다."
assert variable_name == expected_value, f"기대값: {expected_value}, 실제값: {variable_name}"
```

#### 패턴 2: 함수 반환값 확인
```python
assert get_welcome_message('admin') == "관리자님 환영합니다.", \
    "user_role이 'admin'일 때 반환값이 다릅니다."
assert get_welcome_message('user') == "환영합니다.", \
    "user_role이 'user'일 때 반환값이 다릅니다."
```

#### 패턴 3: 함수 출력 확인
```python
import io
from contextlib import redirect_stdout

f = io.StringIO()
with redirect_stdout(f):
    show_welcome_message()
output = f.getvalue().strip()
expected = "Welcome to LogiCore Tech!"
assert output == expected, f"기대값: '{expected}', 실제값: '{output}'"
```

#### 패턴 4: 리스트/딕셔너리 구조 확인
```python
assert isinstance(sprint_tasks, list), "'sprint_tasks' 변수는 리스트(list)여야 합니다."
expected = ['사용자 로그인 기능 개발', '게시판 UI 개선']
assert sprint_tasks == expected, f"기대값: {expected}, 실제값: {sprint_tasks}"
```

#### 패턴 5: 수치 오차 허용 (부동소수점)
```python
assert abs(conversion_rate - 4.0) < 0.001, \
    f"계산된 전환율이 4.0이 아닙니다. 실제 계산값: {conversion_rate}"
```

---

## 2. 시나리오별 테스트 코드 예시

### 2.1 Week 1 - Cycle 0: Python 설치 확인

**테스트 코드**:
```python
import sys
assert sys.version_info.major >= 3, "파이썬 3 이상 버전이 필요합니다."
```

**검증 내용**:
- Python 3.x 버전 설치 확인

### 2.2 Week 2 - Cycle 0: 변수와 자료형

**테스트 코드**:
```python
assert 'service_name' in locals() and service_name == 'LogiCore', \
    "service_name 변수에 'LogiCore' 문자열을 할당해야 합니다."
assert 'concurrent_users' in locals() and concurrent_users == 100, \
    "concurrent_users 변수에 숫자 100을 할당해야 합니다."
assert 'is_active' in locals() and is_active is True, \
    "is_active 변수에 불리언 값 True를 할당해야 합니다."
```

**검증 내용**:
- 변수 선언 여부
- 변수 값의 정확성
- 자료형 확인 (문자열, 숫자, 불리언)

### 2.3 Week 3 - Cycle 0: 조건문

**테스트 코드**:
```python
assert get_welcome_message('admin') == "관리자님 환영합니다.", \
    "user_role이 'admin'일 때 반환값이 다릅니다."
assert get_welcome_message('editor') == "에디터님 안녕하세요.", \
    "user_role이 'editor'일 때 반환값이 다릅니다."
assert get_welcome_message('user') == "환영합니다.", \
    "user_role이 'user'일 때 반환값이 다릅니다."
assert get_welcome_message('guest') == "환영합니다.", \
    "정의되지 않은 role('guest')일 때 '환영합니다.'를 반환해야 합니다."
```

**검증 내용**:
- 함수 구현 여부
- 다양한 입력에 대한 올바른 출력
- 엣지 케이스 처리 (예: 정의되지 않은 role)

### 2.4 Week 4 - Cycle 1: 함수 매개변수와 반환값

**테스트 코드**:
```python
assert get_personalized_greeting('Alex') == "Welcome, Alex!", \
    "get_personalized_greeting('Alex')의 반환값이 'Welcome, Alex!'여야 합니다."
assert calculate_bonus(1000) == 100, \
    "calculate_bonus(1000)의 반환값이 100이어야 합니다."
assert calculate_bonus(500) == 50, \
    "calculate_bonus(500)의 반환값이 50이어야 합니다."
```

**검증 내용**:
- 함수 매개변수 올바른 사용
- 반환값의 정확성
- 여러 테스트 케이스

---

## 3. 코드 실행 및 평가 프로세스

### 3.1 전체 흐름

```
1. 학습자 코드 작성
   ↓
2. "제출" 버튼 클릭
   ↓
3. 사용자 코드 + 테스트 코드 결합
   ↓
4. Pyodide에서 Python 실행
   ↓
5. 결과 판정
   ├─ 성공 → 성공 피드백 표시 → 다음 사이클 진행
   └─ 실패 → 실패 피드백 표시 → 재시도
```

### 3.2 코드 결합 방식

**파일**: [static/codeEditor.js](../../static/codeEditor.js)

```javascript
async function submitCode() {
  // 1. 사용자가 작성한 코드 가져오기
  const userCode = state.monacoEditor.getValue();

  // 2. 시나리오에 정의된 테스트 코드 가져오기
  const cycleData = state.weekData.cycles[state.currentCycleIndex];
  const testCode = cycleData.testCode;

  // 3. 코드 결합
  const combinedCode = userCode + "\n\n" + testCode;

  // 4. Pyodide에서 실행
  const result = await runPythonCode(combinedCode);

  // 5. 결과 판정
  const isSuccess = !result.error;

  // 6. 로그 저장
  await logSubmission(isSuccess, result.error || "");

  // 7. 피드백 표시
  if (isSuccess) {
    showFeedbackModal("success");
  } else {
    // 에러 타입 판단
    const feedbackType = result.error.includes("AssertionError")
      ? "failure_logical"
      : "failure_runtime";
    showFeedbackModal(feedbackType, result.error);
  }
}
```

### 3.3 Pyodide 코드 실행

```javascript
export async function runPythonCode(code) {
  if (!pyodide) {
    return { error: "오류: Python 실행 환경이 준비되지 않았습니다." };
  }

  try {
    // stdout/stderr 리디렉션
    await pyodide.runPythonAsync(`
      import sys, io
      sys.stdout = io.StringIO()
      sys.stderr = io.StringIO()
    `);

    // 코드 실행
    let result = await pyodide.runPythonAsync(code);
    let stdout = await pyodide.runPythonAsync("sys.stdout.getvalue()");
    let stderr = await pyodide.runPythonAsync("sys.stderr.getvalue()");

    // 에러가 있으면 에러 반환
    if (stderr) return { error: stderr };

    // 성공 시 출력 반환
    let output = stdout;
    if (result !== undefined && result !== null) {
      output += String(result);
    }

    return { success: output || "(출력 결과 없음)" };
  } catch (error) {
    return { error: error.toString() };
  }
}
```

---

## 4. 피드백 시스템

### 4.1 피드백 유형

각 사이클마다 3가지 피드백이 정의됩니다:

1. **success**: 테스트 통과 시
2. **failure_logical**: AssertionError (논리 오류)
3. **failure_runtime**: RuntimeError (문법 오류, 실행 오류)

### 4.2 피드백 데이터 구조

**파일**: [scenario.json](../../scenario.json)

```json
{
  "feedback": {
    "success": {
      "character": "alex",
      "subtitle": "업무 완료 피드백",
      "title": "훌륭합니다!",
      "content": "<span class='text-green-300'>테스트를 통과했습니다.</span> 다음 업무로 넘어가죠."
    },
    "failure_logical": {
      "character": "sena",
      "subtitle": "문제 해결 지원",
      "title": "음, 뭔가 이상한데요?",
      "content": "{{ERROR_MESSAGE}} 라는 메시지가 보이네요. 다시 한번 확인해 주시겠어요?"
    },
    "failure_runtime": {
      "character": "sena",
      "subtitle": "문제 해결 지원",
      "title": "앗, 문법 오류!",
      "content": "코드를 실행하다가 오류가 발생했어요. 혹시 실수가 있는지 확인해보세요."
    }
  }
}
```

### 4.3 에러 메시지 파싱

**파일**: [static/codeEditor.js](../../static/codeEditor.js:119-142)

```javascript
export function parseErrorMessage(error) {
  const errorString = String(error);

  // AssertionError 처리 - 사용자 정의 메시지 추출
  const assertionMatch = errorString.match(/AssertionError:\s*(.*)/);
  if (assertionMatch && assertionMatch[1]) {
    return assertionMatch[1].trim();
  }

  // 일반적인 Python 오류 - 마지막 줄 반환
  const lines = errorString.split("\n");
  const lastLine = lines[lines.length - 1].trim();
  if (lastLine) {
    // 에러 타입 이름 제거
    const errorTypeMatch = lastLine.match(/^[a-zA-Z_]+Error:\s*(.*)/);
    if (errorTypeMatch && errorTypeMatch[1]) {
      return errorTypeMatch[1];
    }
    return lastLine;
  }

  return errorString;
}
```

### 4.4 피드백 모달 표시

**에러 메시지 치환**:

```javascript
function showFeedbackModal(feedbackType, errorMessage = "") {
  const feedbackData = cycleData.feedback[feedbackType];

  // {{ERROR_MESSAGE}} 플레이스홀더를 실제 에러 메시지로 치환
  const parsedError = parseErrorMessage(errorMessage);
  const content = feedbackData.content.replace(
    "{{ERROR_MESSAGE}}",
    `<span class="text-red-400">${parsedError}</span>`
  );

  // 모달 렌더링
  feedbackModal.innerHTML = `
    <img src="${IMAGE_URLS[feedbackData.character]}" />
    <h3>${feedbackData.title}</h3>
    <p>${feedbackData.subtitle}</p>
    <div>${content}</div>
    ${feedbackType === 'success' ? '<button>다음 단계로</button>' : '<button>다시 시도</button>'}
  `;

  feedbackModal.classList.remove('hidden');
}
```

---

## 5. 제출 로그 시스템

### 5.1 로그 데이터 구조

**Firestore 컬렉션**: `submission_logs`

```javascript
{
  logId: "log123",
  studentEmail: "hong@example.com",
  classId: "abc123",
  week: 3,
  cycle: 2,
  isSuccess: false,
  error: "AssertionError: service_name 변수에 'LogiCore' 문자열을 할당해야 합니다.",
  submittedAt: Timestamp
}
```

### 5.2 로그 저장 코드

**파일**: [static/codeEditor.js:145-171](../../static/codeEditor.js:145-171)

```javascript
async function logSubmissionToFirestore(isSuccess, errorDetails = "") {
  if (
    !state.currentUser ||
    state.currentUser.role !== "student" ||
    !state.currentUser.classId ||
    !db
  ) return;

  try {
    const logRef = doc(collection(db, "submission_logs"));
    await setDoc(logRef, {
      logId: logRef.id,
      studentEmail: state.currentUser.email,
      classId: state.currentUser.classId,
      week: state.currentWeek,
      cycle: state.currentCycleIndex,
      isSuccess: isSuccess,
      error: String(errorDetails),
      submittedAt: serverTimestamp(),
    });
    console.log("Submission logged successfully.");
  } catch (err) {
    console.error("Failed to log submission:", err);
  }
}
```

### 5.3 로그 활용

**분석 리포트에서 사용**:
- 전체 성공률 계산
- 주차별 성공률
- 가장 실패가 많은 사이클 파악
- 학생별 성과 분석

---

## 6. React + Spring Boot 마이그레이션 시 고려사항

### 6.1 백엔드 (Spring Boot)

**테스트 코드 실행은 클라이언트에서만**:
- Pyodide는 브라우저에서만 실행 가능
- 백엔드는 로그 저장만 담당

```java
// LogController.java
@PostMapping("/api/log/submission")
public ResponseEntity<ApiResponse<Void>> logSubmission(
    @Valid @RequestBody SubmissionLogRequest request
) {
    logService.saveSubmissionLog(request);
    return ResponseEntity.ok(
        ApiResponse.success("제출 기록이 저장되었습니다.")
    );
}
```

### 6.2 프론트엔드 (React)

**usePyodide Hook**:

```typescript
export function usePyodide() {
  const [pyodide, setPyodide] = useState<PyodideInterface | null>(null);

  const runCode = async (code: string) => {
    if (!pyodide) throw new Error('Pyodide not loaded');

    try {
      await pyodide.runPythonAsync(`
        import sys, io
        sys.stdout = io.StringIO()
        sys.stderr = io.StringIO()
      `);

      await pyodide.runPythonAsync(code);
      const stdout = await pyodide.runPythonAsync('sys.stdout.getvalue()');
      const stderr = await pyodide.runPythonAsync('sys.stderr.getvalue()');

      if (stderr) return { error: stderr };
      return { success: stdout };
    } catch (err) {
      return { error: err instanceof Error ? err.message : String(err) };
    }
  };

  return { pyodide, runCode };
}
```

**코드 제출 컴포넌트**:

```typescript
function SubmitButton() {
  const { runCode } = usePyodide();
  const { weekData, currentCycle } = useLearning();
  const [code, setCode] = useState('');

  const handleSubmit = async () => {
    const cycleData = weekData!.cycles[currentCycle];
    const testCode = cycleData.testCode;
    const combinedCode = code + '\n\n' + testCode;

    // 코드 실행
    const result = await runCode(combinedCode);
    const isSuccess = !result.error;

    // 로그 저장 (API 호출)
    await logService.logSubmission({
      week: weekData!.week,
      cycle: currentCycle,
      isSuccess,
      error: result.error || '',
    });

    // 피드백 표시
    if (isSuccess) {
      showFeedback('success');
    } else {
      const feedbackType = result.error.includes('AssertionError')
        ? 'failure_logical'
        : 'failure_runtime';
      showFeedback(feedbackType, result.error);
    }
  };

  return (
    <button onClick={handleSubmit}>제출</button>
  );
}
```

---

## 7. 테스트 코드 작성 가이드

### 7.1 좋은 테스트 코드의 조건

1. **명확한 에러 메시지**: 무엇이 잘못되었는지 알려주기
2. **다양한 케이스**: 정상 케이스, 엣지 케이스 모두 검증
3. **실행 순서 독립성**: 테스트 간 의존성 없음

### 7.2 나쁜 예시

```python
# ❌ 에러 메시지 없음
assert x == 10

# ❌ 너무 엄격한 검증 (부동소수점)
assert conversion_rate == 4.0

# ❌ 불명확한 메시지
assert result == expected, "틀렸습니다."
```

### 7.3 좋은 예시

```python
# ✅ 명확한 에러 메시지
assert x == 10, "변수 x의 값이 10이어야 합니다. 현재 값: {x}"

# ✅ 오차 허용
assert abs(conversion_rate - 4.0) < 0.001, \
    f"전환율이 4.0이어야 합니다. 계산값: {conversion_rate}"

# ✅ 상세한 메시지
assert result == expected, \
    f"기대값: {expected}, 실제값: {result}"
```

---

## 8. 요약

### 코드 평가 핵심 메커니즘

1. **테스트 정의**: scenario.json에 각 사이클마다 `testCode` 정의
2. **코드 결합**: 사용자 코드 + 테스트 코드
3. **실행**: Pyodide에서 Python 코드 실행
4. **판정**: 예외 발생 여부로 합격/불합격 결정
5. **피드백**: 3가지 유형의 맞춤 피드백 제공
6. **로깅**: Firestore에 제출 기록 저장

### 주요 특징

- ✅ 브라우저에서 완전 자동화된 평가
- ✅ 즉각적인 피드백
- ✅ 상세한 에러 메시지
- ✅ 캐릭터 기반 맞춤 피드백
- ✅ 학습 데이터 수집 및 분석

---

**다음 문서**: 실시간 모니터링 시스템 분석
